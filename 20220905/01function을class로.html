<!DOCTYPE html>
<meta charset="UTF-8">
<script>
    /* 
    js에선 function키워드가 함수 키워드로 사용되지만
    java class키워드처럼 객체 정의 생성자로도 사용될 수 있음
    실제 calss키워드도 존재하지만 내부적으로 function키워드로 바뀌게
    되기 때문에 js하는 사람들은 그냥 function키워드를 사용함
    class 키워드를 사용하는 경우는 마이크로소프트의 typescript를
    사용하여 js를 작성하는 경우
    typescript, babel.js등은 transfiler(변환기)라고 불리는데
    typescript로 짜면 그것이 javascript파일로 바뀜
    TIP**면접시 class란 : 사용자정의 데이터타입 
    */

   // function KeyWorld를 class의 의미로 사용할 땐 항상
   // function 블락 끝에 return this; 가 생략되었다고 생각하면 편함
   // 선언(보통 생성자라고도 부름)
    function Block(p_name, p_song){
        this.name = p_name;  // 속성 추가
        this.song = p_song;  // 속성 추가
        /* 메서드를 이렇게 선언하는 것은 추천하지 않음
           prototype에 선언하는 것은 완전 추천, 메모리가 절약됨 
           사실 요즘같이 메모리가 많을 땐 상관없..
        this.sy = function(){  // 메서드 추가
            alert('미아내~~~~' + this.name + '아~~');
        }
        */
        return this;  // 마지막에 이게 붙어있다는 걸 알아야 이해가 잘 됨
    }

    // 국내에선 prototype만 쓰면 잘하는 사람으로 생각
    Block.prototype. sy= function(){
        alert('미아내~~~~' + this.name + '아~~');
    }

    // 생성
    var v_roze1 = new Block('로제', 'Gone');
    console.log(v_roze1);
    v_roze1.sy(); // ?
    var v_roze2 = new Block('다영', '나에게로의 초대');
    console.log(v_roze2);
    v_roze2.sy(); // ?
    if(v_roze1 === v_roze2){
        alert("뜨게질?");
    }

    // 메서드는 전부 따로따로 가질필요가 없다 . 프로토타입에 공유해서 쓰길 권함
</script>